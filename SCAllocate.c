/*********************************************************************	myAllocate.c  -  L.F. Abbott		Routines for allocating memory for PlotCore Program	*********************************************************************/#include <stdlib.h>#include <math.h>#include <Carbon/Carbon.h>#ifndef _NO_USER_LIBRARY_#include <SimulationControllerFramework/SCPlotParameters.h>#include <SimulationControllerFramework/SimulationController.h> #else#include "SCPlotParameters.h"#include "SimulationController.h"#endif#include "SCAllocate.h"#include "SCNR.h"double *Vector(long n)/* allocate a double vector*/{	double 	*v;	long	i;	v=(double *)malloc((size_t) (n*sizeof(double)));	if (!v) 		SCWriteWarning("allocation failure in Vector()");	else	{		for (i=0; i<n; i++)			v[i] = 0.0;	}	return v;}float *fVector(long n)/* allocate a float vector*/{	float 	*v;	long	i;	v=(float *)malloc((size_t) (n*sizeof(float)));	if (!v) 		SCWriteWarning("allocation failure in fVector()");	else	{		for (i=0; i<n; i++)			v[i] = 0.0;	}	return v;}int *IVector(long n)/* allocate an int vector*/{	int 	*v;	long	i;	v=(int *)malloc((size_t) (n*sizeof(int)));	if (!v) 		SCWriteWarning("allocation failure in IVector()");	else	{		for (i=0; i<n; i++)			v[i] = 0;	}	return v;}long *LVector(long n)/* allocate a long vector*/{	long 	*v;	long	i;	v=(long *)malloc((size_t) (n*sizeof(long)));	if (!v) 		SCWriteWarning("allocation failure in LVector()");	else	{		for (i=0; i<n; i++)			v[i] = 0;	}	return v;}SInt32 *SIVector(long n)/* allocate a long vector*/{	SInt32 	*v;	long	i;	v=(SInt32 *)malloc((size_t) (n*sizeof(SInt32)));	if (!v) 		SCWriteWarning("allocation failure in SIVector()");	else	{		for (i=0; i<n; i++)			v[i] = 0;	}	return v;}short *SVector(long n)/* allocate a short vector*/{	short 	*v;	long	i;	v=(short *)malloc((size_t) (n*sizeof(short)));	if (!v) 		SCWriteWarning("allocation failure in SVector()");	else	{		for (i=0; i<n; i++)			v[i] = 0;	}	return v;}Boolean *BVector(long n)/* allocate a Boolean vector */{	Boolean 	*v;	long		i;	v=(Boolean *)malloc((size_t) (n*sizeof(Boolean)));	if (!v) 		SCWriteWarning("allocation failure in BVector()");	else	{		for (i=0; i<n; i++)			v[i] = false;	}	return v;}double **PVector(long n)/* allocate a vector of pointers */{	double 	**v;	long	i;	v=(double **)malloc((size_t) (n*sizeof(double*)));	if (!v) 		SCWriteWarning("allocation failure in PVector()");	else	{		for (i=0; i<n; i++)			v[i] = nil;	}	return v;}short **PSVector(long n)/* allocate a vector of pointers */{	short 	**v;	long	i;	v=(short **)malloc((size_t) (n*sizeof(short*)));	if (!v) 		SCWriteWarning("allocation failure in PSVector()");	else	{		for (i=0; i<n; i++)			v[i] = nil;	}	return v;}long **PLVector(long n)/* allocate a vector of pointers */{	long 	**v;	long	i;	v=(long **)malloc((size_t) (n*sizeof(long*)));	if (!v) 		SCWriteWarning("allocation failure in PLVector()");	else	{		for (i=0; i<n; i++)			v[i] = nil;	}	return v;}SInt32 **PSIVector(long n)/* allocate a vector of pointers */{	SInt32 	**v;	long	i;	v=(SInt32 **)malloc((size_t) (n*sizeof(SInt32*)));	if (!v) 		SCWriteWarning("allocation failure in PSIVector()");	else	{		for (i=0; i<n; i++)			v[i] = nil;	}	return v;}Boolean **PBVector(long n)/* allocate a vector of pointers */{	Boolean **v;	long	i;	v=(Boolean **)malloc((size_t) (n*sizeof(Boolean*)));	if (!v) 		SCWriteWarning("allocation failure in PBVector()");	else	{		for (i=0; i<n; i++)			v[i] = nil;	}	return v;}double **Matrix(long nr, long nc)/* allocate a double matrix*/{	long 	i, j;	double 	**m;	m=(double **) malloc((size_t) (nr*sizeof(double*)));	if (!m) 		SCWriteWarning("allocation failure in Matrix()");	for (i=0; i<nr; i++)	{		m[i]=(double *) malloc((size_t) (nc*sizeof(double)));		if (!m[i])			SCWriteWarning("allocation failure in Matrix()");	}	for (i=0; i<nr; i++)		for (j=0; j<nc; j++)			m[i][j] = 0.0;	return m;}int **IMatrix(long nr, long nc)/* allocate an int matrix */{	long 	i, j;	int 	**m;	m=(int **) malloc((size_t) (nr*sizeof(int*)));	if (!m) 		SCWriteWarning("allocation failure in IMatrix()");	for (i=0; i<nr; i++)	{		m[i]=(int *) malloc((size_t) (nc*sizeof(int)));		if (!m[i])			SCWriteWarning("allocation failure in IMatrix()");	}	for (i=0; i<nr; i++)		for (j=0; j<nc; j++)			m[i][j] = 0;	return m;}float **fMatrix(long nr, long nc)/* allocate an float matrix */{	long 	i, j;	float 	**m;	m=(float **) malloc((size_t) (nr*sizeof(float*)));	if (!m) 		SCWriteWarning("allocation failure in fMatrix()");	for (i=0; i<nr; i++)	{		m[i]=(float *) malloc((size_t) (nc*sizeof(float)));		if (!m[i])			SCWriteWarning("allocation failure in fMatrix()");	}	for (i=0; i<nr; i++)		for (j=0; j<nc; j++)			m[i][j] = 0.0;	return m;}Boolean **BMatrix(long nr, long nc)/* allocate an int matrix */{	long 		i, j;	Boolean 	**m;	m=(Boolean **) malloc((size_t) (nr*sizeof(Boolean*)));	if (!m) 		SCWriteWarning("allocation failure in BMatrix()");	for (i=0; i<nr; i++)	{		m[i]=(Boolean *) malloc((size_t) (nc*sizeof(Boolean)));		if (!m[i])			SCWriteWarning("allocation failure in BMatrix()");	}	for (i=0; i<nr; i++)		for (j=0; j<nc; j++)			m[i][j] = false;	return m;}void FreeVector(double *v){	free(v);}void FreefVector(float *v){	free(v);}void FreeIVector(int *v){	free(v);}void FreeLVector(long *v){	free(v);}void FreeSVector(short *v){	free(v);}void FreeSIVector(SInt32 *v){	free(v);}void FreeBVector(Boolean *v){	free(v);}void FreeMatrix(double **m, long nr, long nc)/* free a double matrix */{	long 	i;		for (i=0; i<nr; i++)		free(m[i]);	free(m);}void FreeIMatrix(int **m, long nr, long nc)/* free an int matrix */{	long 	i;		for (i=0; i<nr; i++)		free(m[i]);	free(m);}void FreefMatrix(float **m, long nr, long nc)/* free a float matrix */{	long 	i;		for (i=0; i<nr; i++)		free(m[i]);	free(m);}