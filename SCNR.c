/* This is the ANSI C version of Numerical Recipes programs modified by me. */#include <stdlib.h>#include <math.h>#include <Carbon/Carbon.h>#ifndef _NO_USER_LIBRARY_#include <SimulationControllerFramework/SCPlotParameters.h>#include <SimulationControllerFramework/SimulationController.h> #else#include "SCPlotParameters.h"#include "SimulationController.h"#endif#include "SCAllocate.h"#include "SCNR.h"#define IA 16807#define IM 2147483647#define AM (1.0/IM)#define IQ 127773#define IR 2836#define NTAB 32#define NDIV (1+(IM-1)/NTAB)#define EPS 1.2e-7#define RNMX (1.0-EPS)void GetDateTimeDCS(unsigned int * random_time){    clock_t time_since_process_started = clock();    *random_time = time_since_process_started;}double Randx(void){	int 			j;	long			k;	static long		iy=0;	static Boolean	firstCall = true;	static long 	iv[NTAB];	float 			temp;	static long		idum;	UInt32			randomTime;	if (firstCall) 	{            firstCall = false;            GetDateTimeDCS(&randomTime);            //randomTime = 0;		idum = (long) randomTime;		if (idum < 0)			idum = -idum; 		if (idum < 1) 			idum = 1;		for (j=NTAB+7;j>=0;j--) 		{			k=idum/IQ;			idum=IA*(idum-k*IQ)-IR*k;			if (idum < 0) 				idum += IM;			if (j < NTAB) 				iv[j] = idum;		}		iy = iv[0];	}	k = idum/IQ;	idum = IA*(idum-k*IQ)-IR*k;	if (idum < 0) 		idum += IM;	j = iy/NDIV;	iy = iv[j];	iv[j] = idum;	if ((temp=AM*iy) > RNMX) 		return (double) RNMX;	else 		return (double) temp;}#undef IA#undef IM#undef AM#undef IQ#undef IR#undef NTAB#undef NDIV#undef EPS#undef RNMX#define IA 16807#define IM 2147483647#define AM (1.0/IM)#define IQ 127773 #define IR 2836#define NTAB 32#define NDIV (1+(IM-1)/NTAB)#define EPS 1.2e-7#define RNMX (1.0-EPS)double RandFixed(Boolean setSeed, long seed){	int 			j;	long			k;	static long		iy=0;	static Boolean	firstCall = true;	static long 	iv[NTAB];	float 			temp;	static long		idum;	if ((setSeed)||(firstCall))	{		firstCall = false;		idum = seed;		if (idum < 0)			idum = -idum; 		if (idum < 1) 			idum = 1;		for (j=NTAB+7;j>=0;j--) 		{			k=idum/IQ;			idum=IA*(idum-k*IQ)-IR*k;			if (idum < 0) 				idum += IM;			if (j < NTAB) 				iv[j] = idum;		}		iy = iv[0];	}	k = idum/IQ;	idum = IA*(idum-k*IQ)-IR*k;	if (idum < 0) 		idum += IM;	j = iy/NDIV;	iy = iv[j];	iv[j] = idum;	if ((temp=AM*iy) > RNMX) 		return (double) RNMX;	else 		return (double) temp;}#undef IA#undef IM#undef AM#undef IQ#undef IR#undef NTAB#undef NDIV#undef EPS#undef RNMX#define IM1 2147483563#define IM2 2147483399#define AM 	(1.0/IM1)#define IMM1 (IM1-1)#define IA1 40014#define IA2	40692#define IQ1 53668#define IQ2 52774#define IR1 12211#define IR2 3791#define NTAB 32#define NDIV (1+IMM1/NTAB)#define EPS 1.2e-7#define RNMX (1.0-EPS)double RandLongx(void){	int 			j;	long			k;	static long		iy=0;	static Boolean	firstCall = true;	static long 	iv[NTAB];	float 			temp;	static long		idum, idum2 = 123456789;	UInt32			randomTime;	if (firstCall) 	{		firstCall = false;		GetDateTimeDCS(&randomTime);                //randomTime = 0;		idum = (long) randomTime;		if (idum < 0)			idum = -idum; 		if (idum < 1) 			idum = 1;		idum2 = idum;		for (j=NTAB+7;j>=0;j--) 		{			k=idum/IQ1;			idum=IA1*(idum-k*IQ1)-IR1*k;			if (idum < 0) 				idum += IM1;			if (j < NTAB) 				iv[j] = idum;		}		iy = iv[0];	}	k = idum/IQ1;	idum = IA1*(idum-k*IQ1)-IR1*k;	if (idum < 0) 		idum += IM1;	k = idum2/IQ2;	idum2 = IA2*(idum2-k*IQ2)-IR2*k;	if (idum2 < 0) 		idum2 += IM2;	j = iy/NDIV;	iy = iv[j] - idum2;	iv[j] = idum;	if (iy < 1)		iy += IMM1;	if ((temp=AM*iy) > RNMX) 		return (double) RNMX;	else 		return (double) temp;}#undef IM1#undef IM2#undef AM#undef IMM1#undef IA1#undef IA2#undef IQ1#undef IQ2#undef IR1#undef IR2#undef NTAB#undef NDIV#undef EPS#undef RNMXdouble FastRand(void){	static unsigned long	jflone = 0x3f800000;	static unsigned long	jflmsk = 0x007fffff;	static unsigned long	idum;	unsigned long			itemp;	float					temp;	static Boolean			firstCall=true;		if (firstCall) 	{		firstCall = false;		//GetDateTimeDCS(&idum);                 idum = 0;		if (idum < 0)			idum = -idum; 	}	idum = 1664525L*idum + 1013904223L;	itemp = jflone | (jflmsk & idum);	temp = (*(float *)&itemp) - 1.0;	return (double) temp;}#define ITMAX 100#define CGOLD 0.3819660#define ZEPS 1.0e-10#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d)double FindMin(double (*f)(double), double ax, double bx, double cx, double tol){	int iter;	double a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;	double e=0.0;	a=(ax < cx ? ax : cx);	b=(ax > cx ? ax : cx);	x=w=v=bx;	fw=fv=fx=(*f)(x);	for (iter=1;iter<=ITMAX;iter++) 	{		xm=0.5*(a+b);		tol2=2.0*(tol1=tol*fabs(x)+ZEPS);		if (fabs(x-xm) <= (tol2-0.5*(b-a))) 		{			return x;		}		if (fabs(e) > tol1) 		{			r=(x-w)*(fx-fv);			q=(x-v)*(fx-fw);			p=(x-v)*q-(x-w)*r;			q=2.0*(q-r);			if (q > 0.0) p = -p;			q=fabs(q);			etemp=e;			e=d;			if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))				d=CGOLD*(e=(x >= xm ? a-x : b-x));			else 			{				d=p/q;				u=x+d;				if (u-a < tol2 || b-u < tol2)					d=SIGN(tol1,xm-x);			}		} 		else 		{			d=CGOLD*(e=(x >= xm ? a-x : b-x));		}		u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));		fu=(*f)(u);		if (fu <= fx) 		{			if (u >= x) 				a=x; 			else 				b=x;			SHFT(v,w,x,u);			SHFT(fv,fw,fx,fu);		} 		else 		{			if (u < x) 				a=u; 			else 				b=u;			if (fu <= fw || w == x) 			{				v=w;				w=u;				fv=fw;				fw=fu;			} 			else if (fu <= fv || v == x || v == w) 			{				v=u;				fv=fu;			}		}	}	SCWriteWarning("Too many iterations in FindMin");	return x;}#undef ITMAX#undef CGOLD#undef ZEPS#undef SIGN#undef SHFTdouble RandExp(void){	double dum;	do		dum=Randx();	while (dum == 0.0);	return -log(dum);}double RandGauss(void){	static int 		iset=0;	static double 	gset;	double 			fac,rsq,v1,v2;	if  (iset == 0) 	{		do 		{			v1=2.0*Randx()-1.0;			v2=2.0*Randx()-1.0;			rsq=v1*v1+v2*v2;		} 		while (rsq >= 1.0 || rsq == 0.0);		fac=sqrt(-2.0*log(rsq)/rsq);		gset=v1*fac;		iset=1;		return v2*fac;	} 	else 	{		iset=0;		return gset;	}}#define EPS 1.0e-6#define JMAX 20double Integrate(double (*func)(double), double a, double b){	double trapzd(double (*func)(double), double a, double b, int n);	void nrerror(char error_text[]);	int j;	double s,st,ost,os;	ost = os = -1.0e30;	for (j=1;j<=JMAX;j++) 	{		st=trapzd(func,a,b,j);		s=(4.0*st-ost)/3.0;		if (fabs(s-os) < EPS*fabs(os)) 			return s;		os=s;		ost=st;	}	SCWriteWarning("Too many steps in routine Integrate");	return s;}#undef EPS#undef JMAX#define FUNC(x) ((*func)(x))double trapzd(double (*func)(double), double a, double b, int n){	double x,tnm,sum,del;	static double s;	int it,j;	if (n == 1) 	{		return (s=0.5*(b-a)*(FUNC(a)+FUNC(b)));	} 	else 	{		for (it=1,j=1;j<n-1;j++) it <<= 1;		tnm=it;		del=(b-a)/tnm;		x=a+0.5*del;		for (sum=0.0,j=1;j<=it;j++,x+=del) sum += FUNC(x);		s=0.5*(s+(b-a)*sum/tnm);		return s;	}}#undef FUNCvoid DifEq(void (*derivs)(double, double[], double[]), double x, double y[], 	int n, double h, double dydx[], double dym[], double dyt[], double yt[]){	int i;	double xh,hh,h6;		(*derivs)(x,y,dydx);	hh=h*0.5;	h6=h/6.0;	xh=x+hh;	for (i=0;i<n;i++) 		yt[i]=y[i]+hh*dydx[i];	(*derivs)(xh,yt,dyt);	for (i=0;i<n;i++) 		yt[i]=y[i]+hh*dyt[i];	(*derivs)(xh,yt,dym);	for (i=0;i<n;i++) 	{		yt[i]=y[i]+h*dym[i];		dym[i] += dyt[i];	}	(*derivs)(x+h,yt,dyt);	for (i=0;i<n;i++)		y[i]=y[i]+h6*(dydx[i]+dyt[i]+2.0*dym[i]);}#define ITMAX 100#define EPS 3.0e-8#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))int FindZero(double (*func)(double), double *answer, double x1, double x2, double tol){	int iter;	double a=x1,b=x2,c=x2,d,e,min1,min2;	double fa=(*func)(a),fb=(*func)(b),fc,p,q,r,s,tol1,xm;	if ((fa > 0.0 && fb > 0.0) || (fa < 0.0 && fb < 0.0))	{		SCWriteWarning("Root must be bracketed in FindZero");		return 0;	}	fc=fb;	for (iter=1;iter<=ITMAX;iter++) 	{		if ((fb > 0.0 && fc > 0.0) || (fb < 0.0 && fc < 0.0)) 		{			c=a;			fc=fa;			e=d=b-a;		}		if (fabs(fc) < fabs(fb)) 		{			a=b;			b=c;			c=a;			fa=fb;			fb=fc;			fc=fa;		}		tol1=2.0*EPS*fabs(b)+0.5*tol;		xm=0.5*(c-b);		if (fabs(xm) <= tol1 || fb == 0.0) 		{			*answer = b;			return 1;		}		if (fabs(e) >= tol1 && fabs(fa) > fabs(fb)) 		{			s=fb/fa;			if (a == c) 			{				p=2.0*xm*s;				q=1.0-s;			} 			else 			{				q=fa/fc;				r=fb/fc;				p=s*(2.0*xm*q*(q-r)-(b-a)*(r-1.0));				q=(q-1.0)*(r-1.0)*(s-1.0);			}			if (p > 0.0) q = -q;			p=fabs(p);			min1=3.0*xm*q-fabs(tol1*q);			min2=fabs(e*q);			if (2.0*p < (min1 < min2 ? min1 : min2)) 			{				e=d;				d=p/q;			} 			else 			{				d=xm;				e=d;			}		} 		else 		{			d=xm;			e=d;		}		a=b;		fa=fb;		if (fabs(d) > tol1)			b += d;		else			b += SIGN(tol1,xm);		fb=(*func)(b);	}	SCWriteWarning("Maximum number of iterations exceeded in FindZero");	return -1;}#undef ITMAX#undef EPS#undef SIGNint RandPoisson(double xm){	double 			em, t, y;	static double 	sq, alxm, g, oldm=(-1.0);	int				im;		if (xm<12.0)	{		if (xm!=oldm)		{			oldm = xm;			g = exp(-xm);		}		em = -1;		t = 1.0;		do 		{			++em;			t *= Randx();		} while (t > g);	}	else	{		if (xm!=oldm)		{			oldm = xm;			sq = sqrt(2.0*xm);			alxm = log(xm);			g = xm*alxm - gammln(xm+1.0);		}		do 		{			do			{				y = tan(pi*Randx());				em = sq*y + xm;			} while (em < 0.0);			em = floor(em);			t = 0.9*(1.0 + y*y)*exp(em*alxm - gammln(em+1.0) - g);		} while (Randx() > t);	}	im = (int) em;	return im;			}double gammln(double xx){	double 			x, y, tmp, ser;	static double 	cof[6] = {76.18009172947146, -86.50532032941677, 						24.01409824083091, -1.231739572450155, 						0.1208650973866179e-2, -0.5395239384953e-5};	int				j;		x = xx;	y = x;	tmp = x + 5.5;	tmp -= (x + 0.5)*log(tmp);	ser = 1.000000000190015;	for (j=0; j<=5; j++)		ser += cof[j]/++y;	return -tmp+log(2.5066282746310005*ser/x);}#define WINDOW(j, a, b) (1.0-fabs(((j)-(a))*(b)))  /* Bartlett */void PowerSpec(double data[], double p[], int m, int k){	/* Power spectrum at m points with frequencies j/(2*m*Delta) 		from (2k+1)*m datat points.  */	void 	four1(double data[], unsigned long nn, int isign);	int 	mm, m4, kk, joffn, joff, j2, j, iDat;	double 	w, sq, facp, facm, *w1, *w2, sumw, den;	mm = m + m;	m4 = mm + mm;	w1 = Vector(m4);	w2 = Vector(m);	facm = (double) m;	facp = 1.0/ (double) m;	sumw = 0.0;	for (j=0; j<mm; j++) 	{		sq = WINDOW(j, facm, facp);		sumw += sq*sq;	}	for (j=0; j<m; j++) 		p[j] = 0.0;	iDat = 0;	for (j=0; j<m; j++) 	{		w2[j] = data[iDat];		iDat++;	}	den = 0.0;	for (kk=0; kk<k; kk++) 	{		for (joff=0; joff<=1; joff++) 		{ 			for (j=0; j<m; j++) 				w1[joff+j+j] = w2[j];			for (j=0; j<m; j++) 			{				w2[j] = data[iDat];				iDat++;			}			joffn = joff + mm;			for (j=0; j<m; j++) 				w1[joffn+j+j] = w2[j];		}		for (j=0; j<mm; j++) 		{			j2 = j + j;			w = WINDOW(j, facm, facp);			w1[j2] *= w;			w1[j2+1] *= w;		}		four1(w1, mm, 1);		p[0] += w1[0]*w1[0] + w1[1]*w1[1];		for (j=1; j<m; j++) 		{			j2 = j + j;			p[j] += w1[j2]*w1[j2] + w1[j2+1]*w1[j2+1];			p[j] += w1[m4+1-j2]*w1[m4+1-j2] + w1[m4-j2]*w1[m4-j2];		}		den += sumw;	}	den *= m4;	for (j=0; j<m; j++)		p[j] /= den;	FreeVector(w2);	FreeVector(w1);}#undef WINDOW#define SWAP(a, b) tempr=(a);(a)=(b);(b)=temprvoid four1(double data[], unsigned long nn, int isign){	unsigned long 	n, mmax, m, j, istep, i;	double 			wtemp, wr, wpr, wpi, wi, theta;	double 			tempr, tempi;	n = nn << 1;	j = 0;	for (i=0; i<n-1; i+=2) 	{		if (j>i) 		{			SWAP(data[j], data[i]);			SWAP(data[j+1], data[i+1]);		}		m = n >> 1;		while ((m>=2)&&(j>m-1)) 		{			j -= m;			m >>= 1;		}		j += m;	}	mmax = 2;	while (n>mmax) 	{		istep = mmax << 1;		theta = isign*(6.28318530717959/mmax);		wtemp = sin(0.5*theta);		wpr = -2.0*wtemp*wtemp;		wpi = sin(theta);		wr = 1.0;		wi = 0.0;		for (m=1; m<mmax; m+=2) 		{			for (i=m-1; i<n; i+=istep) 			{				j = i + mmax;				tempr = wr*data[j] - wi*data[j+1];				tempi = wr*data[j+1] + wi*data[j];				data[j] = data[i] - tempr;				data[j+1] = data[i+1] - tempi;				data[i] += tempr;				data[i+1] += tempi;			}			wr = (wtemp=wr)*wpr - wi*wpi + wr;			wi = wi*wpr+wtemp*wpi + wi;		}		mmax = istep;	}}#undef SWAP